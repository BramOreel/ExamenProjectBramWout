Index: src/RPG/Purse.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package RPG;\r\n\r\npublic class Purse extends Equipable{\r\n    private Purse(int weight){\r\n        super(weight);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/RPG/Purse.java b/src/RPG/Purse.java
--- a/src/RPG/Purse.java	(revision 7615e532895fb21acdbee5946f0f63706cfcf319)
+++ b/src/RPG/Purse.java	(date 1683652322656)
@@ -1,5 +1,11 @@
 package RPG;
 
+/**
+ * A class for backpacks in an RPG.
+ *
+ * @author Bram Oreel
+ * @version 1.0.
+ */
 public class Purse extends Equipable{
     private Purse(int weight){
         super(weight);
Index: src/RPG/Creature.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package RPG;\r\nimport be.kuleuven.cs.som.annotate.Basic;\r\nimport be.kuleuven.cs.som.annotate.Model;\r\nimport be.kuleuven.cs.som.annotate.Raw;\r\nimport java.util.Random;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Iterator;\r\n\r\npublic abstract class Creature {\r\n\r\n    /**\r\n     * Creates a new creature with a name, amount of hitpoints and capactity.\r\n     * @param name\r\n     *        The name of the new creature.\r\n     * @param maxHitPoints\r\n     *        The maximum amount of hitpoints of the creature.\r\n     * @param maxCapacity\r\n     *        The maximum capacity of the creature in kg.\r\n     * @effect The new name is set to the name of the creature, if the name is not valid\r\n     *         an IllegalArgumentException is thrown.\r\n     *         |setName(name)\r\n     * @effect The maximum capacity is set to the given maxCapacity.\r\n     *         |setMaxCapacity(maxCapacity)\r\n     * @effect The remaining capacity is set to the given maxCapacity,\r\n     *          because the creature still has an empty inventory.\r\n     *         |setCapacity(maxCapacity)\r\n     * @effect The maximum amount of hitpoints is set to the given maxHitPoints.\r\n     *         |setMaxHitPoints(maxHitPoints)\r\n     * @effect The amount of hitpoints is set to the given maxHitPoints,\r\n     *          so the creature has full health.\r\n     *         |setHitPoints(maxHitPoints)\r\n     */\r\n    protected Creature(String name, int maxHitPoints, int maxCapacity) {\r\n        setName(name);\r\n        setMaxCapacity(maxCapacity);\r\n        setCapacity(maxCapacity);\r\n        setMaxHitPoints(maxHitPoints);\r\n        setHitPoints(maxHitPoints);\r\n\r\n    }\r\n\r\n    /**\r\n     * variable containing the name of the Creature\r\n     */\r\n    protected String name;\r\n\r\n    /**\r\n     * variable containing maximum amount of hitpoints\r\n     */\r\n    protected int maxHitPoints;\r\n\r\n    /**\r\n     * vatiable containing the amount of hitpoints\r\n     */\r\n    protected int hitPoints;\r\n\r\n    /**\r\n     * variable containing the current remaining capacity of the creature in kg\r\n     */\r\n    protected int capacity;\r\n\r\n    /**\r\n     * variable containing the maximum capacity the creature can carry in kg\r\n     */\r\n    protected int maxCapacity;\r\n\r\n\r\n    /**\r\n     * a list containing all valid characters for the name.\r\n     */\r\n    protected final static String validCharacters = \"[a-zA-Z': ]+\";\r\n\r\n    /**\r\n     * @return  the name of the creature\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * @return  the maximum hitpoints of the creature.\r\n     */\r\n    public int getMaxHitPoints() {\r\n        return maxHitPoints;\r\n    }\r\n\r\n    /**\r\n     * @return  the hitpoints of the creature.\r\n     */\r\n    public int getHitPoints() {\r\n        return hitPoints;\r\n    }\r\n\r\n    /**\r\n     * @return the current remaining capacity of the creature.\r\n     */\r\n    public int getCapacity() {\r\n        return capacity;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @return the maximum capacity of the creature.\r\n     */\r\n    public int getMaxCapacity() {\r\n        return maxCapacity;\r\n    }\r\n\r\n    /**\r\n     * Sets a new given max hitpoints.\r\n     * @param maxHitPoints\r\n     *        the given amount.\r\n     * @pre   the given amount must be a valid amount.\r\n     *        | isValidMaxHitpoints(capacity)\r\n     * @post  the amount of maxhitpoints is now the given amount.\r\n     *        | this.maxHitPoints == maxHitPoints\r\n     */\r\n    protected void setMaxHitPoints(int maxHitPoints) {\r\n        this.maxHitPoints = maxHitPoints;\r\n    }\r\n    /**\r\n     * Sets a new given amount of hitpoints.\r\n     * @param hitPoints\r\n     *        the given amount.\r\n     * @pre   the given amount must be a valid amount.\r\n     *        | isValidHitPoints(hitPoints)\r\n     * @post  the amount of hitpoints is now the given amount.\r\n     *        | this.hitPoints == hitPoints\r\n     */\r\n    protected void setHitPoints(int hitPoints) {\r\n        this.hitPoints = hitPoints;\r\n    }\r\n    /**\r\n     * Sets a new given remaining capacity.\r\n     * @param capacity\r\n     *        the given amount.\r\n     * @pre   the given amount must be a valid amount.\r\n     *        | isValidCapacity(capacity)\r\n     * @post  the amount of remaining capacity is now the given amount.\r\n     *        | this.capacity == capacity\r\n     */\r\n    protected void setCapacity(int capacity) {\r\n        this.capacity = capacity;\r\n    }\r\n\r\n    /**\r\n     * Adds a remaining capacity.\r\n     * @param capacity\r\n     *        the given amount, can be negative.\r\n     * @pre   the given amount must make the new capacity a valid amount.\r\n     *        | isValidCapacity(getCapacity()-capacity)\r\n     * @effect  the amount of remaining capacity is now the previous amount plus the given weigt.\r\n     *        | setCapacity(getCapacity()+capacity)\r\n     */\r\n    protected void ChangeCapacity(int capacity) {\r\n        setCapacity(getCapacity()+capacity);\r\n    }\r\n    /**\r\n     * Sets a new given maximum capacity.\r\n     * @param maxCapacity\r\n     *        the given amount.\r\n     * @pre   the given amount must be a valid amount.\r\n     *        | isValidMaxCapacity(maxCapacity)\r\n     * @post  the maximum capacity is now the given amount.\r\n     *        | this.maxCapacity == maxCapacity\r\n     */\r\n    protected void setMaxCapacity(int maxCapacity) {\r\n            this.maxCapacity = maxCapacity;\r\n    }\r\n\r\n    /**\r\n     * checks if the maxCapacity is a valid amount.\r\n     * @param   maxCapacity\r\n     *          the maxCapacity that needs to be checked.\r\n     * @return  True if the amount is a non-negative integer, false if not.\r\n     *          | maxCapacity > -1\r\n     */\r\n    public boolean isValidMaxCapacity(int maxCapacity){\r\n        return maxCapacity > -1;\r\n    }\r\n\r\n    /**\r\n     * checks if the remaining capacity is a valid amount.\r\n     * @param   capacity\r\n     *          the remaining capacity that needs to be checked.\r\n     * @return  True if the amount is a non-negative integer smaller than the maximum capacity, false if not.\r\n     *          | getMaxCapacity() > capacity &&  capacity > -1\r\n     */\r\n    public boolean isValidCapacity(int capacity){\r\n        return  getMaxCapacity() > capacity &&  capacity > -1;\r\n    }\r\n\r\n    /**\r\n     * checks if the maxHitPoints is a valid amount.\r\n     * @param   maxHitPoints\r\n     *          the maximum amount of hitpoints that needs to be checked.\r\n     * @return  True if the amount is a non-negative integer, false if not.\r\n     *          | maxHitPoints > -1\r\n     */\r\n    public boolean isValidMaxHitPoints(int maxHitPoints){\r\n        return maxHitPoints > -1;\r\n    }\r\n\r\n    /**\r\n     * checks if the remaining amount of hitpoints is a valid amount.\r\n     * @param   hitPoints\r\n     *          the remaining amount of hitpoints that needs to be checked.\r\n     * @return  True if the amount is a non-negative integer smaller than the maximum amount, false if not.\r\n     *          | getMaxHitPoints() > hitPoints &&  hitPoints > -1\r\n     */\r\n    public boolean isValidHitpoints(int hitPoints){\r\n        return  getMaxHitPoints() > hitPoints &&  hitPoints > -1;\r\n    }\r\n\r\n    /**\r\n     * Checks if a given name is valid.\r\n     * @param name\r\n     *        the given name that gets checked.\r\n     * @return True if all the characters in the given name are valid characters, the name is not null\r\n     *          and the first character is a capital letter.\r\n     *        | name.matches(validCharacters) && name != null && name.matches(\"^[A-Z].*\")\r\n     */\r\n    @Raw\r\n    public boolean isValidName(String name){\r\n        return name.matches(validCharacters) && name != null && name.matches(\"^[A-Z].*\");\r\n    }\r\n\r\n    /**\r\n     * Sets a new name.\r\n     * @param  name\r\n     *         The new name.\r\n     * @throws IllegalArgumentException\r\n     *         If the given name is not valid this exception is thrown.\r\n     *         | !isValidName(name)\r\n     * @post   The new name is set as the given name.\r\n     *         | this.name == name\r\n     */\r\n    protected void setName(String name) throws IllegalArgumentException{\r\n        if(!isValidName(name)){\r\n            throw new IllegalArgumentException();\r\n        }\r\n        else {\r\n            this.name = name;\r\n        }\r\n    }\r\n    /********\r\n     * Anchors\r\n     */\r\n\r\n    /**\r\n     * A list containing 'anchors' referencing the anchors for this creature.\r\n     */\r\n    protected ArrayList<Anchor> anchors = new ArrayList<Anchor>();\r\n\r\n    /**\r\n     * Returns the list of anchors of this creature\r\n     */\r\n    @Basic\r\n    public ArrayList<Anchor> getAnchors() {\r\n        return anchors;\r\n    }\r\n\r\n    /**\r\n     * Sets the list of anchors to the given list.\r\n     *\r\n     * @param anchors\r\n     *        The new anchors for this creature\r\n     */\r\n    @Model\r\n    protected void setAnchors(ArrayList<Anchor> anchors) {\r\n        this.anchors = anchors;\r\n    }\r\n\r\n    /**\r\n     * returns the anchor with index i in the arraylist of anchors.\r\n     *\r\n     * @param i\r\n     *        The given index for the anchor in the arraylist of anchors\r\n     */\r\n    public Anchor getAnchorAt(int i){\r\n        return getAnchors().get(i);\r\n    }\r\n\r\n    /**\r\n     * Returns the item being stored in the anchor with given index i in the arraylist of anchors.\r\n     *\r\n     * @param i\r\n     *        The given index for the anchor in the arraylist of anchors.\r\n     */\r\n    public Equipable getAnchorItemAt(int i){\r\n        return getAnchorAt(i).getItem();\r\n    }\r\n\r\n    /**\r\n     * Picks an item up from the ground and equips it in a specified anchorslot.\r\n     *\r\n     * @param item\r\n     *        the item that will be picked up.\r\n     * @param anchortype\r\n     *        the name of the anchor where the item has to be equiped to.\r\n     *\r\n     * @effect The carry capacity for this creature is updated to account for the extra weight of the item that was picked up.\r\n     *         In case the item is a backpack, the contents of this backpack are also considered for the calculation\r\n     *         of the weight of the item.\r\n     *         |ChangeCapacity(item.totalweight);\r\n     * @effect The item gets picked up and the unidirectional relation between the item and the given anchor gets set up.\r\n     *         |item.equip(anchor)\r\n     *\r\n     * @throws ItemAlreadyobtainedException\r\n     *         The item already has a holder which means it can't be picked up.\r\n     *         |item.getHolder == null\r\n     * @throws IllegalArgumentException\r\n     *         The item is not effective\r\n     *         |item == null\r\n     * @throws BeltAnchorException\r\n     *         The user wants to equip an item that isn't a purse to the belt anchorslot of the creature.\r\n     *         |anchortype.getName() == \"Riem\" && item not instanceof Purse\r\n     * @throws IllegalArgumentException\r\n     *         The creature does not have an anchor with the given type as its type.\r\n     *         |Anchors.contains(anchortype) == false\r\n     * @throws AnchorslotOquipiedException\r\n     *         The creature is already holding an item in the anchor with the given anchortype\r\n     *         |anchor.getItem() != null\r\n     * @throws CarryLimitReachedException\r\n     *         The given item is can't be picked up because the creature cannot carry it anymore\r\n     *         because the maximum carry capacity has been reached. In case the user wants to pick up a backpack,\r\n     *         the contents of this backpack are also considered for the calculation of the weight of the item.\r\n     *         |item.getTotalWeight > getCapacity\r\n     */\r\n    @Raw @Model\r\n    protected void pickUp(Equipable item, AnchorType anchortype) throws ItemAlreadyobtainedException,IllegalArgumentException,\r\n            AnchorslotOquipiedException, CarryLimitReachedException, BeltAnchorException {\r\n        if (item.getHolder() != null) {\r\n            throw new ItemAlreadyobtainedException();\r\n        }\r\n        if (item == null)\r\n            throw new IllegalArgumentException();\r\n\r\n        if (anchortype.getName() == \"Riem\" && !(item instanceof Purse))\r\n            throw new BeltAnchorException();\r\n\r\n        Anchor anchor = null;\r\n\r\n        ArrayList<Anchor> list = getAnchors();\r\n        for (int i = 0; i < list.size(); i++) {\r\n            Anchor curranchor = getAnchorAt(i);\r\n            if (curranchor.getAnchorType() == anchortype) {\r\n                if(curranchor.getItem() == null){\r\n                    anchor = curranchor;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(anchor == null)\r\n            throw new IllegalArgumentException();\r\n\r\n        if (anchor.getItem() != null)\r\n            throw new AnchorslotOquipiedException();\r\n\r\n        int weight = item.getWeight();\r\n        if(item instanceof Backpack)\r\n            weight = ((Backpack) item).getTotalWeight();\r\n\r\n        if (weight > getCapacity())\r\n            throw new CarryLimitReachedException(item);\r\n\r\n        item.equip(anchor);\r\n        ChangeCapacity(weight);\r\n    }\r\n\r\n    /**\r\n     * Drops an item that has been picked up back on the ground.\r\n     *\r\n     * @param equipable\r\n     *        The equipable to be dropped\r\n     *\r\n     * @effect if the given equipable is currently being stored in a backpack then\r\n     *         the item is removed from the content of that backpack. Else, if the item is being stored\r\n     *         in an anchor, the item is removed from the anchor.\r\n     *         |if(equipable.getParentbackpack != null){\r\n     *         |  equipable.getParentback.removeEquipable(equipable)\r\n     *         |}\r\n     *         |else{\r\n     *         |    itemanchor.setItem(null)\r\n     *         |}\r\n     * @effect The holder of the item is set to null.\r\n     *         |equipable.setHolder(null)\r\n     * @effect The maximum carry capacity for this creature is updated to account for the removed weight of the item.\r\n     *         If the removed item is a backpack with content,\r\n     *         the contents of this backpack are also considered for the calculation of the removed weight for the item.\r\n     *         |totalWeight = equipable.getWeight()\r\n     *         |if(equipable instanceof Backpack)\r\n     *         |    totalWeight = ((Backpack) equipable).getTotalWeight();\r\n     *         |ChangeCapacity(-totalWeight);\r\n     *\r\n     * @throws IllegalArgumentException\r\n     *         The equipable item is not effective\r\n     *         |equipable == null\r\n     * @throws OtherPlayersItemException\r\n     *         The holder of the item isn't the creature that executes this method.\r\n     *         |equipable.getHolder() != this\r\n     */\r\n    @Raw\r\n    public void drop(Equipable equipable) throws IllegalArgumentException, OtherPlayersItemException{\r\n        if(equipable == null)\r\n            throw new IllegalArgumentException();\r\n        if(equipable.getHolder() != this)\r\n            throw new OtherPlayersItemException();\r\n\r\n\r\n        Anchor itemanchor = null;\r\n\r\n        for(int i =0; i<getAnchors().size();i++){\r\n\r\n            Equipable currItem = getAnchorItemAt(i);\r\n\r\n            if(currItem == equipable){\r\n                itemanchor = getAnchorAt(i);\r\n                break;}\r\n\r\n            else if(currItem instanceof Backpack){\r\n                if(((Backpack) currItem).contains(equipable)){\r\n                    ((Backpack) currItem).removeEquipable(equipable);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(itemanchor != null)\r\n            itemanchor.setItem(null);\r\n\r\n        equipable.setHolder(null);\r\n\r\n        int totalWeight = equipable.getWeight();\r\n        if(equipable instanceof Backpack)\r\n            totalWeight = ((Backpack) equipable).getTotalWeight();\r\n\r\n        ChangeCapacity(-totalWeight);\r\n    }\r\n\r\n    /**\r\n     * Drops the item currently stored in the specified Anchor.\r\n     *\r\n     * @param anchor\r\n     *        the anchor of which we want to remove the item.\r\n     *\r\n     * @effect The item in the given anchor gets dropped\r\n     *         |drop(anchor.getItem())\r\n     *\r\n     * @throws IllegalArgumentException\r\n     *         The equipable item is not effective\r\n     *         |equipable == null\r\n     * @throws OtherPlayersItemException\r\n     *         The specified anchor is an anchor of another player or the item in the anchor belongs to another player\r\n     *         |(anchor.getowner != this) || (anhor.getItem.getHolder != this)\r\n     */\r\n    @Raw\r\n    public void dropItemAtAnchor(Anchor anchor) throws IllegalArgumentException, OtherPlayersItemException {\r\n        drop(anchor.getItem());\r\n    }\r\n\r\n\r\n    /**\r\n     * Drops all the items that this creature currently has equiped in its anchors.\r\n     *\r\n     * @effect Each anchor that has a non-null item, will drop its item.\r\n     *         |if (getAnchorAt(i).getItem() != null)\r\n     *         |    dropItemAtAnchor(getAnchorAt(i));\r\n     */\r\n    @Raw\r\n    public void dropAllItems() {\r\n        for(int i=0; i < getAnchors().size();i++){\r\n            if (getAnchorAt(i).getItem() != null) {\r\n                try {\r\n                    dropItemAtAnchor(getAnchorAt(i));\r\n                } catch (OtherPlayersItemException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates a value to see if the attack will hit.\r\n     * @return A random integer between 0 and 100.\r\n     *         | return rand.nextInt(101)\r\n     */\r\n    @Model\r\n    protected int getHitValue(){\r\n        Random rand = new Random();\r\n        int randomNum = rand.nextInt(101);\r\n        return randomNum;\r\n    }\r\n    /**\r\n     * @return The total damage including weapons and intrinsic damage.\r\n     */\r\n    protected abstract int getTotalDamage();\r\n\r\n    /**\r\n     * @return The total protection stat including armor and intrinsic protection.\r\n     */\r\n    protected abstract int getTotalProtection();\r\n\r\n    /**\r\n     * The creature dies and unequips all his items that can now be looted.\r\n     * @return  a list that contains all the items of the dead creature.\r\n     * @effect  all the items that the dead creature owned will be unequiped.\r\n     *          |for(item in items of creature)\r\n     *          |        unequip(item)\r\n     */\r\n    protected ArrayList<Equipable> die() throws ItemNotEquipedException{\r\n        ArrayList<Equipable> items = new ArrayList<Equipable>();\r\n        for(Anchor anchor : getAnchors()){\r\n            if(anchor.getItem() != null){\r\n                if(anchor.getItem() instanceof Backpack){\r\n                    ArrayList<Equipable> itemsInBackpack = ((Backpack) anchor.getItem()).getAllItems();\r\n                }\r\n                items.add(anchor.getItem());\r\n                anchor.getItem().unequip(anchor);\r\n            }\r\n        }\r\n        return items;\r\n    }\r\n\r\n    /**\r\n     * Makes a creature loot and/or heal after a won battle.\r\n     * @param items\r\n     *        The items that can be looted.\r\n     */\r\n    protected abstract void LootAndHeal(ArrayList<Equipable> items) throws ItemNotEquipedException, ItemAlreadyobtainedException, CarryLimitReachedException, AnchorslotOquipiedException;\r\n\r\n    public void Hit(Creature creature) throws ItemNotEquipedException, ItemAlreadyobtainedException, CarryLimitReachedException, AnchorslotOquipiedException {\r\n        if(getHitValue() >= getTotalProtection()){\r\n            creature.setHitPoints(creature.getHitPoints() - getTotalDamage());\r\n            }\r\n        if(creature.getHitPoints() <= 0){\r\n            creature.setHitPoints(0);\r\n            LootAndHeal(creature.die());\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/RPG/Creature.java b/src/RPG/Creature.java
--- a/src/RPG/Creature.java	(revision 7615e532895fb21acdbee5946f0f63706cfcf319)
+++ b/src/RPG/Creature.java	(date 1683652322539)
@@ -257,8 +257,8 @@
     /**
      * Returns the list of anchors of this creature
      */
-    @Basic
-    public ArrayList<Anchor> getAnchors() {
+    @Basic @Model
+    protected ArrayList<Anchor> getAnchors() {
         return anchors;
     }
 
@@ -273,13 +273,27 @@
         this.anchors = anchors;
     }
 
+    /**
+     *Returns the number of anchors for this creature
+     */
+    @Basic
+    public int getNbOfAnchors(){
+        return getAnchors().size();
+    }
+
+
     /**
      * returns the anchor with index i in the arraylist of anchors.
      *
      * @param i
      *        The given index for the anchor in the arraylist of anchors
+     * @throws IllegalArgumentException
+     *         the index i is out of range
+     *         |i > getNbOfAnchors()
      */
-    public Anchor getAnchorAt(int i){
+    public Anchor getAnchorAt(int i) throws  IllegalArgumentException{
+        if(i > getNbOfAnchors())
+            throw new IllegalArgumentException();
         return getAnchors().get(i);
     }
 
Index: src/RPG/Equipable.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package RPG;\r\n\r\nimport be.kuleuven.cs.som.annotate.Basic;\r\nimport be.kuleuven.cs.som.annotate.Immutable;\r\nimport be.kuleuven.cs.som.annotate.Model;\r\nimport be.kuleuven.cs.som.annotate.Raw;\r\n\r\nimport java.util.UUID;\r\n\r\n/**\r\n * An abstract class of equipable items for heroes and monsters\r\n *\r\n * @invar Each equipable item must have a valid identification number.\r\n *        | canHaveAsId(getId())\r\n *\r\n * @invar Each equipable item must have a valid weight\r\n *        | canHaveAsWeight(getWeight())\r\n *\r\n * @invar Each equipable item must have a allowed value\r\n *        | isValidValue(getValue())\r\n *\r\n * @note Subclasses may only add/strengthen invariants (Liskov principle).\r\n *\r\n * @author Bram Oreel\r\n * @version 1.0\r\n *\r\n */\r\npublic abstract class Equipable {\r\n\r\n    /**\r\n     * Initialize a new Equipable item with a given weight and holder\r\n     *\r\n     * @param weight\r\n     *        The weight of the equipable item in kilograms\r\n     * @param holder\r\n     *        The current holder of the equipable item\r\n     * @effect if the given weight is valid, the weight is set to the specified value, else the weight of this item is set to 5 kilograms.\r\n     *          |if(canHaveAsWeight(weight))\r\n     *              this.weight = weight\r\n     *          else this.weight = 5\r\n     */\r\n    @Raw @Model\r\n    protected Equipable(int weight, Creature holder){\r\n        if(canHaveAsWeight(weight))\r\n            this.weight = weight;\r\n        else this.weight = 5;\r\n        setHolder(holder);\r\n    }\r\n\r\n    /**\r\n     * Initialize a new Equipable item with a given weight without a holder. In the game this 'spawns' a new item.\r\n     * @param weight\r\n     *        The weight of the equipable item in kilograms.\r\n     * @effect An equipable is initialised with given weight and a 'null' type holder.\r\n     *         |this(weight, null)\r\n     */\r\n    @Raw @Model\r\n    protected Equipable(int weight){\r\n        this(weight,null);\r\n    }\r\n\r\n\r\n\r\n    /***********************\r\n     * Identification\r\n     */\r\n\r\n    /**\r\n     * Variable listing the Identification number of the item.\r\n     */\r\n    private long Id;\r\n\r\n\r\n    /**\r\n     *\r\n     * Return the Id of the equipable item\r\n     */\r\n    @Basic @Immutable\r\n    public long getId() {\r\n        return Id;\r\n    }\r\n\r\n    /**\r\n     * Sets the id of this equipable item to the given id.\r\n     * @param id\r\n     *        the unique id for an equipable item\r\n     * @post If the given id is valid, which it should be at this point in the code, this equipable item is set to the given id,\r\n     *       otherwise the id is set to zero. At this point uniqueness cannot be guaranteed.\r\n     *       | if (canHaveAsId(id))\r\n     * \t     | then new.getId().equals(id)\r\n     * \t     | else new.getId().equals(0)\r\n     *\r\n     *\r\n     */\r\n    @Raw @Model\r\n    protected final void setId(long id) {\r\n        if(canHaveAsId(id))\r\n            Id = id;\r\n        else Id = 0;\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * Check whether the equipable item can have the given id as its id\r\n     * @param id\r\n     *        the id to be checked\r\n     * @return False if the id has a negative value or is greater then the maximum integer value.\r\n     *         | if(id < 0 || id > Integer.MAX_VALUE)\r\n     *         | then result == false\r\n     * @note This checker only checks the common rule between all the subclasses. Whether or not the id is unique is resolved by the subclasses.\r\n     *\r\n     */\r\n    @Raw @Model\r\n    protected boolean canHaveAsId(long id){\r\n       return(id >= 0 && id < Integer.MAX_VALUE);\r\n\r\n    }\r\n\r\n\r\n    /*********************************\r\n     * Weight\r\n     */\r\n\r\n    /**\r\n     * a final variable containing the weight of an Equipable item in kilograms\r\n     */\r\n    private final int weight;\r\n\r\n    /**\r\n     *\r\n     * Returns the weight of this equipable\r\n     */\r\n    @Basic\r\n    public int getWeight() {\r\n        return weight;\r\n    }\r\n\r\n    /**\r\n     * Checks if an equipable item can have this value as its weight.\r\n     *\r\n     * @param weight\r\n     *        the weight of the equipable item\r\n     * @return True if the value is greater than zero\r\n     *         |if(weight > 0) then result == True\r\n     */\r\n    @Raw\r\n    public boolean canHaveAsWeight(long weight){\r\n        return(weight > 0);\r\n    }\r\n\r\n    /************\r\n     * Value\r\n     */\r\n\r\n    /**\r\n     * A variable containing the value of an Equipable item in 'dukaten'\r\n     */\r\n    private int value = 1;\r\n\r\n    /**\r\n     * Returns the value of the equipable item\r\n     */\r\n    @Basic\r\n    public int getValue() {\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     *Sets the value for this equipable item to the given item\r\n     *\r\n     * @param value\r\n     *        the new value for this equipable item\r\n     *\r\n     * @throws IllegalArgumentException\r\n     *         The given value is a integer less thann one.\r\n     *         |value < 1\r\n     */\r\n    @Raw @Model\r\n    protected void setValue(int value) throws IllegalArgumentException {\r\n        if(!isValidValue(value))\r\n            throw new IllegalArgumentException();\r\n        this.value = value;\r\n    }\r\n\r\n    /**\r\n     * Checks whether an equipable item can have this value as its value.\r\n     *\r\n     * @param value\r\n     *        the value to be checked\r\n     *\r\n     * @return False if the given value is smaller than one.\r\n     *        |if(value < 1) then result == False\r\n     */\r\n    @Model @Raw\r\n    protected boolean isValidValue(int value){\r\n        return(value >= 1);\r\n    }\r\n\r\n\r\n    /********\r\n     * Holder\r\n     */\r\n\r\n    /**\r\n     * A variabele referencing the creature object that currently holds this equipable item.\r\n     */\r\n    private Creature holder = null;\r\n\r\n    /**\r\n     *\r\n     * Returns the holder of this equipable item\r\n     */\r\n    @Basic\r\n    public Creature getHolder() {\r\n        return holder;\r\n    }\r\n\r\n    /**\r\n     * Sets the holder of this equipable item to the given holder\r\n     * @param holder\r\n     *        the new holder for this equipable item\r\n     */\r\n    @Model\r\n    protected void setHolder(Creature holder) {\r\n        this.holder = holder;\r\n    }\r\n\r\n    /**\r\n     * A variable referencing the backpack this equipable item is stored in.\r\n     * Null means that the item is currently not stored within a backpack.\r\n     */\r\n    private Backpack parentbackpack = null;\r\n\r\n    /**\r\n     * Returns the backpack that the equipable is currently being stored in.\r\n     *\r\n     */\r\n    @Basic\r\n    public Backpack getParentbackpack() { return parentbackpack;}\r\n\r\n    /**\r\n     * Sets the parent backpack for this item to the specified backpack.\r\n     *\r\n     * @param parentbackpack\r\n     *        The new parent backpack for this equipable item.\r\n     */\r\n    @Model\r\n    protected void setParentbackpack(Backpack parentbackpack) {this.parentbackpack = parentbackpack;}\r\n\r\n    /**\r\n     *\r\n     * @param anchor\r\n     * @throws IllegalArgumentException\r\n     */\r\n\r\n    /**\r\n     * Sets up the unidirectional relation between the anchors of a creature and the items stored in them.\r\n     *\r\n     * @param anchor\r\n     *        The anchor that this equipable item will be stored in.\r\n     *\r\n     * @effect The item equiped in the given anchorslot is set to this item.\r\n     *         |anchor.setItem(this)\r\n     * @effect The holder of this equipable item is set to the owner of the anchor\r\n     *         |setHolder(anchor.getOwner());\r\n     */\r\n    @Model @Raw\r\n    protected void equip(Anchor anchor){\r\n        anchor.setItem(this);\r\n        setHolder(anchor.getOwner());\r\n    }\r\n\r\n\r\n    //Gelieve de shit aan te passen zodat ze de methodes gebruiken in creature en hero want hier zitten echt teveel fouten in\r\n\r\n    /**\r\n     * Equips an equipable in a random empty anchor of the monster.\r\n     * @param monster\r\n     *        The monster that has to equip the item.\r\n     * @effect The item will be added to the first empty anchor. If there is no free anchor nothing happens.\r\n     *        | for(Anchor anchor : monster.getAnchors())\r\n     *        |     if (anchor.getItem() == null)\r\n     *        |         equip(anchor);\r\n     *        |         break;\r\n     */\r\n    protected void equip(Monster monster) throws IllegalArgumentException, ItemAlreadyobtainedException, CarryLimitReachedException, AnchorslotOquipiedException{\r\n        if (getHolder() != null) {\r\n            throw new ItemAlreadyobtainedException();\r\n        }\r\n        if (monster == null) {\r\n            throw new IllegalArgumentException();\r\n        }\r\n        for(Anchor anchor : monster.getAnchors()) {\r\n            if (anchor.getItem() == null) {\r\n                equip(anchor);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public void unequip(Anchor anchor) throws IllegalArgumentException, ItemNotEquipedException{\r\n        if(anchor.getItem() != this) throw new ItemNotEquipedException();\r\n        anchor.setItem(null);\r\n        this.setHolder(null);\r\n        anchor.getOwner().ChangeCapacity(-getWeight());\r\n    }\r\n\r\n    /**\r\n     * Unequips an item if the creature has the item equiped\r\n     * @param creature\r\n     *        The creature that holds the item.\r\n     * @effect The Item is unequiped in the anchor that contained it.\r\n     *         |for(Anchor anchor : creature.getAnchors())\r\n     *         |   if (anchor.getItem() == this)\r\n     *         |       unequip(anchor);\r\n     */\r\n    public void unequip(Creature creature)throws ItemNotEquipedException, IllegalArgumentException{\r\n        if(creature == null){\r\n            throw new IllegalArgumentException();\r\n        }\r\n        boolean done = false;\r\n        for(Anchor anchor : creature.getAnchors()) {\r\n            if (anchor.getItem() == this) {\r\n                done = true;\r\n                unequip(anchor);\r\n                break;\r\n            }\r\n        }\r\n        if(!done) throw new ItemNotEquipedException();\r\n    }\r\n\r\n    /**\r\n     * Checks if the equipable can be equiped by an anchor\r\n     * @param anchor\r\n     *        the anchor that would equip the equipable\r\n     * @return True\r\n     */\r\n\r\n    public boolean isValidAnchor(Anchor anchor){\r\n        return true;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/RPG/Equipable.java b/src/RPG/Equipable.java
--- a/src/RPG/Equipable.java	(revision 7615e532895fb21acdbee5946f0f63706cfcf319)
+++ b/src/RPG/Equipable.java	(date 1683647561086)
@@ -192,8 +192,8 @@
      * @return False if the given value is smaller than one.
      *        |if(value < 1) then result == False
      */
-    @Model @Raw
-    protected boolean isValidValue(int value){
+    @Raw //refactor
+    public boolean isValidValue(int value){
         return(value >= 1);
     }
 
Index: src/RPG/Backpack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package RPG;\r\n\r\nimport be.kuleuven.cs.som.annotate.Basic;\r\nimport be.kuleuven.cs.som.annotate.Immutable;\r\nimport be.kuleuven.cs.som.annotate.Model;\r\nimport be.kuleuven.cs.som.annotate.Raw;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\n/**\r\n * A class for backpacks within an RPG\r\n *\r\n * @invar Each backpack must have a valid capacity\r\n *        |isValidCapacity(capacity)\r\n *\r\n * @author Bram Oreel\r\n * @version 1.2.\r\n *\r\n */\r\npublic class Backpack extends Equipable{\r\n\r\n    /**\r\n     * Initialize a new backpack with given identification number, weight, value and capacity\r\n     *\r\n     * @param id\r\n     *        The identification number for this backpack\r\n     * @param weight\r\n     *        The weight in kilograms of this new backpack\r\n     * @param value\r\n     *        The value in 'dukaten' of this new backpack\r\n     * @param capacity\r\n     *        The maximum capacity for this backpack in kilograms.\r\n     * @effect The new backpack is an equipable with the given weight as its weight.\r\n     *         |super(weight)\r\n     * @effect The identification number is configured so that it is unique and positive\r\n     *         |configure(id)\r\n     * @effect If the given value is valid, the value for this backpack is set to the given value, else an exception is thrown.\r\n     *         |if(isValidValue(value)) then this.value = value\r\n     * @effect If the given maximum capacity is valid, the maximum capacity for this backpack is set to the given maximum capacity,\r\n     *         else the capacity for this backpack is set to 30 kilograms.\r\n     *         |if(canHaveAsCapacity(capacity))\r\n     *         |    then this.capacity = capacity\r\n     *         |else this.capacity = 30\r\n     *\r\n     * @throws IllegalArgumentException\r\n     *         The given value is smaller than one or greater than 500.\r\n     *         |value < 1 || value > 500\r\n     */\r\n\r\n    @Raw\r\n    public Backpack(long id, int weight, int value, int capacity) throws IllegalArgumentException{\r\n        super(weight);\r\n        configure(id);\r\n        if(!isValidValue(value))\r\n            throw new IllegalArgumentException();\r\n        setValue(value);\r\n        if(!canHaveAsCapacity(capacity))\r\n            this.capacity = 30;\r\n        else this.capacity = capacity;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Static variable containing the set of previous Backpack id's.\r\n     */\r\n    private static Set<Long> idSet = new HashSet<>();\r\n\r\n\r\n    /**\r\n     * checks if the backpack can have the given id as its id\r\n     * @param id\r\n     *        the id to be checked\r\n     * @return False if the idcounter is negative, greater than the maximum integer value or already an existant id for another backpack.\r\n     *         |if(idcounter < 0 || idcounter > Integer.MAX_VALUE || idSet.contains(id))\r\n     *         | then result == false\r\n     */\r\n    @Override @Raw @Model\r\n    protected boolean canHaveAsId(long id){\r\n        return(super.canHaveAsId(id) && !idSet.contains(id));\r\n    }\r\n\r\n    /**\r\n     * Sets the id to the specified value.\r\n     * @param id\r\n     *        the value of the given id\r\n     * @post If the given id is unique, the backpack id is set to the specified id,\r\n     *       otherwise the id is set to the closest, bigger integer.\r\n     *       | if(canHaveAsId(id))\r\n     * \t     | then new.getId().equals(id)\r\n     * \t     | else new.getId().equals(closestBiggerInteger(id))\r\n     */\r\n    @Model @Raw\r\n    private void configure(long id){\r\n\r\n        while(!canHaveAsId(id)){\r\n            id++;}\r\n\r\n        setId(id);\r\n        idSet.add(id);\r\n    }\r\n\r\n    /***************\r\n     * Content\r\n     **************/\r\n\r\n    /**\r\n     * A variable referencing a hashmap which contains the equipable items\r\n     * contained by this backpack. The key of the hashmap references the id of the\r\n     * equipable item. Because different equipable items can have the same id, the values in this hashmap are lists of equipables items\r\n     * with the same id. Content can only be added in the constructor of Monster and through\r\n     * the pickup method in the hero class and the drop and transfer methods in the creature class.\r\n     *\r\n     * @invar The total weight of the backpacks content cannot exceed its carrying capacity.\r\n     *        |item.getWeight() != ((Backpack) item).getTotalWeight()\r\n     * @invar content references an effective hashmap.\r\n     *        |content != null\r\n     * @invar Every key in the hashmap references an effective id\r\n     *        |for each key in content\r\n     *        |isValidId(key) && key !=null\r\n     * @invar Every value in the hashmap references an effective arraylist\r\n     *        |for each value in content\r\n     *        |value != null\r\n     * @invar The id of in every equipable item in the arraylist of each value in the hashmap is the correct\r\n     *        id of the equipable item\r\n     *        |for each list in content\r\n     *        |  for each equipable in list\r\n     *        |    equipable.getId() == content.key(listAtIndex(i))\r\n     *\r\n     * @note in this implementation, Creature or hero will be the controlling class for calling these methods\r\n     */\r\n    private HashMap<Long, ArrayList<Equipable>> content = new HashMap<Long, ArrayList<Equipable>>();\r\n\r\n    /**\r\n     * Returns the content of the hashmap\r\n     */\r\n    @Basic\r\n    protected HashMap<Long, ArrayList<Equipable>> getContent() {\r\n        return content;\r\n    }\r\n\r\n    /**\r\n     * Gives all the items in the backpack in a list.\r\n     */\r\n    public ArrayList<Equipable> getAllItems(){\r\n        ArrayList<Equipable> AllItems = new ArrayList<Equipable>();\r\n        for(ArrayList<Equipable> list : getContent().values()){\r\n           for(Equipable item:list){\r\n               AllItems.add(item);\r\n           }\r\n        }\r\n        return AllItems;\r\n    }\r\n\r\n\r\n    /**\r\n     * Checks if the content of this backpack contains an equipable item with the given id as its id.\r\n     * @param id\r\n     *        the id to be checked\r\n     * @return True if the given id is stored as one of the keys in the content hashmap.\r\n     *         |getContent().containsKey(id)\r\n     */\r\n    public boolean containsID(long id){\r\n        return getContent().containsKey(id);\r\n    }\r\n\r\n    /**\r\n     * Checks if the content of this backpack contains this equipable item.\r\n     * @param item\r\n     *        the item to be checked\r\n     * @return True if the given item is stored in one of the arraylists, which are the values of the content hashmap.\r\n     *         False if the id of the item is not stored as one of the keys in the content hashmap.\r\n     *         else False\r\n     *         |if(getContent().get(id).contains(item))\r\n     *         |   return true;\r\n     *         |else return false\r\n     */\r\n    public boolean contains(Equipable item){\r\n        long id = item.getId();\r\n        if(!containsID(id))\r\n            return false;\r\n\r\n        else if(getContent().get(id).contains(item))\r\n            return true;\r\n\r\n        else return false;\r\n\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of items stored in this backpack\r\n     */\r\n    public int getNbOfItems() {\r\n        int total = 0;\r\n        for (ArrayList<Equipable> list : getContent().values()) {\r\n            total = total + list.size();\r\n        }\r\n        return total;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the number of armors stored in a backpack\r\n     */\r\n    public int getNbOfArmors(){\r\n        int total = 0;\r\n        for(ArrayList<Equipable> list : getContent().values()){\r\n            for(int i=0; i<list.size(); i++){\r\n                 if(list.get(i) instanceof Armor)\r\n                     total++;\r\n            }\r\n        }\r\n      return total;\r\n    }\r\n\r\n    /**************\r\n     *Weight\r\n     **************/\r\n\r\n    /**\r\n     * Returns the total weight of this backpack\r\n     *\r\n     * @return the sum of the total weight for each equipable item stored in this backpack plus the weight of the backpack itself.\r\n     *          |result == sum {for(int i 0: content.size)\r\n     *                              getItemAt(i).getTotalWeight} + this.getWeight()\r\n     */\r\n    public int getTotalWeight(){\r\n        int sum = 0;\r\n        for(ArrayList<Equipable> list : getContent().values()){\r\n            for(int i=0; i<list.size(); i++){\r\n                sum += list.get(i).getWeight();\r\n            }\r\n        }\r\n        sum += this.getWeight();\r\n        return sum;\r\n    }\r\n\r\n    /**************\r\n     * Value\r\n     **************/\r\n\r\n\r\n    /**\r\n     * Returns the total value of this backpack\r\n     *\r\n     * @return the sum of the total value for each equipable item stored in this backpack plus the value of the backpack itself.\r\n     *          |result == sum {for(int i 0: content.size)\r\n     *                              getItemAt(i).getTotalValue} + this.getValue()\r\n     */\r\n    public int getTotalValue(){\r\n        int sum = 0;\r\n        for(ArrayList<Equipable> list : getContent().values()){\r\n            for(int i=0; i<list.size(); i++){\r\n                sum += list.get(i).getValue();\r\n            }\r\n        }\r\n        sum += this.getValue();\r\n        return sum;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the given value is a valid value for this backpack\r\n     * @param value\r\n     *        the value to be checked\r\n     *\r\n     * @return False if the given value for this backpack is less than 1 or\r\n     *               if the given value for this backpack is greater than 500.\r\n     *         |if(value < 1 || value > 500) then result == False\r\n     */\r\n    @Override @Raw\r\n    public boolean isValidValue(int value){\r\n        return(super.isValidValue(value) && value <= 500);\r\n    }\r\n\r\n\r\n    /*********\r\n     * Capacity\r\n     */\r\n\r\n    /**\r\n     * A final variable referencing the maximum weight of all things this backpack can store in kilograms.\r\n     */\r\n    private final int capacity;\r\n\r\n    /**\r\n     * Checks if the given capacity is a valid capacity for this backpack.\r\n     *\r\n     * @param capacity\r\n     *        the capacity value to be checked\r\n     * @return True if the capacity is a positive value.\r\n     */\r\n    @Raw\r\n    public boolean canHaveAsCapacity(int capacity){\r\n        return(capacity >= 0);\r\n    }\r\n\r\n    /**\r\n     * Returns the capacity for this backpack\r\n     */\r\n    @Basic @Immutable\r\n    public int getCapacity() {\r\n        return capacity;\r\n    }\r\n\r\n    /**\r\n     * Add the given equipable item to the items registered in this backpack\r\n     * and sets the indentification of the item as the key in the hashmap.\r\n     * @param item\r\n     *        The equipable item to be added.\r\n     *\r\n     * @effect The holder of the item is set to the current holder of this backpack.\r\n     *         |item.setHolder(this.getHolder())\r\n     * @effect The parent backpack of the equipable item is set to this backpack\r\n     *         |item.setParentbackpack(this)\r\n     * @post if the identification number is already used as an identification number,\r\n     *       the list linked to the key is appended with the given item.\r\n     *       if the identification number hasn't been used yet, a new entry is created.\r\n     *       |  if(!containsID(id)){\r\n     *       |      getContent().put(id, new ArrayList<Equipable>())\r\n     *       |  getContent().get(id).add(item);\r\n     *\r\n     * @throws BackPackNotEmptyException\r\n     *         The item to be added is a backpack that hasn't been emptied.\r\n     *         |(Backpack) item.getWeight != (Backpack) item.getTotalWeight()\r\n     * @throws CarryLimitReachedException\r\n     *         The item cannot be added because the maximum carrying capacity has been reached.\r\n     *         |this.getCapacity() < this.getTotalWeight()+item.getWeight()\r\n     * @throws ItemAlreadyobtainedException\r\n     *         The item is already being stored in this backpack\r\n     *         |this.contains(item) == True\r\n     * @throws OtherPlayersItemException\r\n     *         The item is already being stored in another backpack\r\n     *         |item.getHolder != null\r\n     * @throws NullPointerException\r\n     *         This backpack is not equiped by anyone\r\n     *         |this.getHolder == null\r\n     *\r\n     */\r\n    @Model\r\n    protected void addEquipable(Equipable item) throws BackPackNotEmptyException, CarryLimitReachedException, OtherPlayersItemException, ItemAlreadyobtainedException,\r\n            NullPointerException{\r\n        if(item instanceof Backpack){\r\n            if(item.getWeight() != ((Backpack) item).getTotalWeight())\r\n                throw new BackPackNotEmptyException((Backpack) item);\r\n        }\r\n        if(getCapacity() < getTotalWeight()+item.getWeight())\r\n            throw new CarryLimitReachedException(item);\r\n\r\n        if(contains(item))\r\n            throw new ItemAlreadyobtainedException();\r\n\r\n        if(getHolder() == null)\r\n            throw new NullPointerException();\r\n\r\n        //Bij pickup in creature class kijken of creature niet al dood is.\r\n        item.setHolder(this.getHolder());\r\n        long id = item.getId();\r\n\r\n        if(!containsID(id)){\r\n            getContent().put(id, new ArrayList<Equipable>());\r\n        }\r\n\r\n        getContent().get(id).add(item);\r\n        item.setParentbackpack(this);\r\n    }\r\n\r\n    /**\r\n     * Remove the given equipable item from the content of this backpack.\r\n     *\r\n     * @param item\r\n     *        The item to remove.\r\n     * @effect The holder of the given item is set to null\r\n     *         |item.setHolder(null)\r\n     * @effect The parent backpack of the equipable item is set to null\r\n     *         |item.setParentbackpack(null)\r\n     * @post If the size of the arraylist, belonging to the id key of the content hashmap is equal to one,\r\n     *       the entire entry is deleted, else only the item at the index where the equipable item was located is deleted,\r\n     *       decrementing the size of the arraylist by one\r\n     *       |getContent().get(id).remove(item);\r\n     *       |if(getContent().get(id).size() == 0) {getContent().remove(id)}\r\n     *\r\n     * @throws IllegalArgumentException\r\n     *         The item to be removed is not contained within the contents of content.\r\n     *         |(this.contains(item) == False\r\n     */\r\n    @Model\r\n    protected void removeEquipable(Equipable item) throws IllegalArgumentException{\r\n        if(!contains(item))\r\n            throw new IllegalArgumentException();\r\n        item.setHolder(null);\r\n\r\n        long id = item.getId();\r\n        getContent().get(id).remove(item);\r\n\r\n        if(getContent().get(id).size() == 0){\r\n            getContent().remove(id);\r\n        }\r\n        item.setParentbackpack(null);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/RPG/Backpack.java b/src/RPG/Backpack.java
--- a/src/RPG/Backpack.java	(revision 7615e532895fb21acdbee5946f0f63706cfcf319)
+++ b/src/RPG/Backpack.java	(date 1683647561119)
@@ -156,6 +156,10 @@
     }
 
 
+
+
+
+
     /**
      * Checks if the content of this backpack contains an equipable item with the given id as its id.
      * @param id
Index: src/RPG/Hero.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package RPG;\r\nimport java.util.ArrayList;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\nimport be.kuleuven.cs.som.annotate.Model;\r\nimport be.kuleuven.cs.som.annotate.Raw;\r\nimport java.util.Random;\r\nimport java.text.DecimalFormat;\r\n\r\n/**\r\n *\r\n *\r\n *\r\n *\r\n * @invar a hero may only carry up to 2 armors at a time.\r\n *       |canCarryArmor\r\n */\r\npublic class Hero extends Creature{\r\n\r\n    /**\r\n     * Generates a new Hero with a name, a maximum amount of hitpoints, a given strength stat and a given protetection stat.\r\n     * Also initialises five Anchors of the anchor class\r\n     *\r\n     * @param name\r\n     *        The given name of the new Hero\r\n     * @param maxHitPoints\r\n     *        The given maximum amount of hitpoints the Hero can have\r\n     * @param strength\r\n     *        The given strength the hero has\r\n     * @param protection\r\n     *        The given protection stat the hero has.\r\n     *@effect The maxcapacity is calculated with the given strength and then set as the strength.\r\n     *        |setMaxCapacity(calculateMaxCapacity(strength));\r\n     *@effect The Hero is generated as a creature with a given name, maxHitPoints and the calculated maxCapacity.\r\n     *        | super(name, maxHitPoints, maxCapacity)\r\n     *@effect The protection is set as the protection.\r\n     *        | setProtection(protection)\r\n     *@effect The strength is set as the strength.\r\n     *        | setStrength(strength)\r\n     *@effect five empty anchors are initialised and set as the anchors of this hero. One left hand, One right hand, one back, one chest and one belt.\r\n     *        |initialiseAnchors();\r\n     */\r\n\r\n    public Hero(String name, int maxHitPoints, double strength, int protection) {\r\n        super(name, maxHitPoints, (int) (20*strength));\r\n        setMaxCapacity(calculateMaxCapacity(strength));\r\n        setProtection(protection);\r\n        setStrength(strength);\r\n        initialiseAnchors();\r\n    }\r\n\r\n    /**\r\n     * Generates a new hero with items equiped.\r\n     * @param name\r\n     *        The given name of the new Hero\r\n     * @param maxHitPoints\r\n     *        The given maximum amount of hitpoints the Hero can have\r\n     * @param strength\r\n     *        The given strength the hero has\r\n     * @param protection\r\n     *        The given protection stat the hero has.\r\n     * @param items\r\n     *        The given items that the Hero has to equip.\r\n     * @effect The Hero gets generated with the given name, maxhipoints, strength and protection.\r\n     *        | this(name, maxHitPoints, strength, protection)\r\n     * @effect All the given items get equiped in the free anchor slots, if there is no empty\r\n     *         compatible anchor left the item does not get equiped.\r\n     *         |for(Equipable item : items)\r\n     *         |   for(Anchor anchor : getAnchors())\r\n     *         |       if(item.isValidAnchor(anchor) && anchor.getItem() == null)\r\n     *         |           item.equip(item)\r\n     */\r\n    public Hero(String name, int maxHitPoints, double strength, int protection, Equipable... items) throws CarryLimitReachedException,ItemAlreadyobtainedException,AnchorslotOquipiedException {\r\n        this(name, maxHitPoints, strength, protection);\r\n        for(Equipable item : items){\r\n            for(Anchor anchor : getAnchors()){\r\n                if(item.isValidAnchor(anchor) && anchor.getItem() == null){\r\n                    try {\r\n                        pickUp(item, anchor.getAnchorType());\r\n                    } catch (ItemAlreadyobtainedException e) {\r\n                        throw new RuntimeException(e);\r\n                    } catch (AnchorslotOquipiedException e) {\r\n                        throw new RuntimeException(e);\r\n                    } catch (CarryLimitReachedException e) {\r\n                        throw new RuntimeException(e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates a new Hero with a name, a maximum amount of hitpoints, a given strength stat and the default protetection stat.\r\n     * @param name\r\n     *        The given name of the new Hero\r\n     * @param maxHitPoints\r\n     *        The given maximum amount of hitpoints the Hero can have\r\n     * @param strength\r\n     *        The given strength the hero has\r\n     *@effect The hero is generated as a hero with the default protection stat.\r\n     *        | this(name,maxHitPoints,strength,getDefaultProtection())\r\n     */\r\n    public Hero(String name, int maxHitPoints, double strength){\r\n        this(name,maxHitPoints,strength,getDefaultProtection());\r\n    }\r\n\r\n\r\n    /**\r\n     * variable stating how much protection the hero has, how easily he can dodge or deflect attacks.\r\n     */\r\n    protected int protection;\r\n    /**\r\n     * the default amount of protection for a hero\r\n     */\r\n    protected static final int defaultProtection = 10;\r\n    /**\r\n     * this static states how many decimal places a strenth variable can have.\r\n     */\r\n    private static final int decimalPlacesStrength = 2;\r\n    /**\r\n     * A variable stating the intrinsic strength of a Hero.\r\n     */\r\n    protected double Strength;\r\n\r\n    /**\r\n     * @return the intrinsic protection of the hero\r\n     */\r\n    public int getProtection() {\r\n        return protection;\r\n    }\r\n\r\n    /**\r\n     * @return the default protection of heroes\r\n     */\r\n    public static int getDefaultProtection() {\r\n        return defaultProtection;\r\n    }\r\n\r\n    /**\r\n     * @return the strenth of the hero\r\n     */\r\n    public double getStrength() {\r\n        return Strength;\r\n    }\r\n\r\n    /**\r\n     * Set the protection to a given number\r\n     * @param protection\r\n     *        the given protection\r\n     * @post  If the given protection is a strictly positive number, then it will be set as the protection.\r\n     *        If it is not, then the protection will be set to the default amount.\r\n     *        | if(protection > 0):\r\n     *        |     this.protection = protection\r\n     *        | else:\r\n     *        |     this.protection = getDefaultProtection()\r\n     */\r\n    public void setProtection(int protection) {\r\n        if(protection > 0){\r\n            this.protection = protection;\r\n        }\r\n        else{\r\n            this.protection = getDefaultProtection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a new strength and rounds it to the right amount of decimals.\r\n     * @param strength\r\n     *        the given strength\r\n     * @post  The strength of the hero is set to the given number rounded off to the amount of decimal\r\n     *        places given by decimalPlacesStrength.\r\n     *        |this.Strength == Math.round(strength * Math.pow(10, decimalPlacesStrength)) / Math.pow(10, decimalPlacesStrength)\r\n     */\r\n    public void setStrength(double strength) {\r\n        Strength = Math.round(strength * Math.pow(10, decimalPlacesStrength)) / Math.pow(10, decimalPlacesStrength);\r\n    }\r\n    /**\r\n     * Calculates the maximum capacity with the given strength.\r\n     * @param strength\r\n     *        the strength of the character.\r\n     * @return The maximum capacity of the hero based on the rules,\r\n     *         the maximum capacity is 20 times the strength, rounded off an integer.\r\n     *         | maxcapacity == Math.round(strength * 20)\r\n     *\r\n     */\r\n    public int calculateMaxCapacity(double strength){\r\n        return (int) Math.round(strength * 20);\r\n    }\r\n    /**\r\n     * Checks if a given name is valid.\r\n     * @param name\r\n     *        the given name that gets checked.\r\n     * @return True if all the characters in the given name are valid characters, the name is not null\r\n     *          ,the first character is a capital letter, it does not include more than two apostrophes and\r\n     *          every colon is followed by a whitespace.\r\n     *        | name.matches(validCharacters) && name != null && name.matches(\"^[A-Z].*\") && apostrophecount < 3  && allColonsFollowedBySpace\r\n     */\r\n    @Raw\r\n    @Override\r\n    public boolean isValidName(String name){\r\n        int apostrophecount = 0;\r\n        for (int i = 0; i < name.length(); i++) {\r\n            if (name.charAt(i) == '\\'') {\r\n                apostrophecount++;\r\n            }\r\n        }\r\n        Pattern pattern = Pattern.compile(\":\\\\S\");\r\n        Matcher matcher = pattern.matcher(name);\r\n        boolean allColonsFollowedBySpace = !matcher.find() && !(name.charAt(name.length() - 1) == ':');\r\n        return (name.matches(validCharacters) && name != null && name.matches(\"^[A-Z].*\") && apostrophecount < 3  && allColonsFollowedBySpace);\r\n    }\r\n\r\n    /**\r\n     * Anchors\r\n     */\r\n    private void initialiseAnchors(){\r\n        ArrayList<Anchor> list = new ArrayList<Anchor>();\r\n        list.add(new Anchor(AnchorType.LINKERHAND,this));\r\n        list.add(new Anchor(AnchorType.RECHTERHAND,this));\r\n        list.add(new Anchor(AnchorType.RUG,this));\r\n        list.add(new Anchor(AnchorType.LICHAAM,this));\r\n        list.add(new Anchor(AnchorType.RIEM,this));\r\n        setAnchors(list);\r\n    }\r\n\r\n    /**\r\n     * Returns the damage that the hero will do if it hits.\r\n     * @return The intrinsic strength + the damage values of both weapons minus ten and then this number divided in half\r\n     *         and rounded down.\r\n     *         |return Math.floor((getStrength() + leftWeapon.getDamage(). + RightWeapon.getDamage - 10)/2)\r\n     */\r\n    @Override\r\n    protected int getTotalDamage(){\r\n        double damage = getStrength();\r\n        for(Anchor anchor : getAnchors()){\r\n            if(anchor.getAnchorType() == AnchorType.LINKERHAND || anchor.getAnchorType() == AnchorType.RECHTERHAND){\r\n                if(anchor.getItem() != null){\r\n                    Weapon weapon = (Weapon) anchor.getItem();\r\n                    damage += weapon.getDamage();\r\n                }\r\n            }\r\n        }\r\n        return (int) Math.floor((damage-10)/2);\r\n    }\r\n\r\n    /**\r\n     * Gives the total protection stat of the hero.\r\n     * @return The total protection stat that is the intrinsic protection with the currentpotection that the\r\n     *         equiped armor gives.\r\n     *         |return getProtection() + armor.getCurrentArmor()\r\n     */\r\n\r\n    @Override\r\n    protected int getTotalProtection(){\r\n        int protection = getProtection();\r\n        for(Anchor anchor : getAnchors()){\r\n            if(anchor.getAnchorType() == AnchorType.LICHAAM){\r\n                if(anchor.getItem() != null){\r\n                    Armor armor = (Armor) anchor.getItem();\r\n                    protection += armor.getCurrentArmor();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return protection;\r\n    }\r\n    @Override\r\n    protected void LootAndHeal(ArrayList<Equipable> items) throws ItemNotEquipedException, ItemAlreadyobtainedException, CarryLimitReachedException, AnchorslotOquipiedException {\r\n        for(Anchor anchor: getAnchors()){\r\n            for(Equipable item: items){\r\n                if(item.isValidAnchor(anchor)){\r\n                    if(item.getValue() > anchor.getItem().getValue()){\r\n                        if(anchor.getItem().getWeight()-item.getWeight() <= getCapacity())\r\n                            anchor.getItem().unequip(anchor);\r\n                            item.equip(anchor);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        Random random = new Random();\r\n        double percentage = random.nextDouble();\r\n        int hp = (int) Math.round((getMaxHitPoints() - getHitPoints()) * percentage + getHitPoints());\r\n        setHitPoints(findClosestPrime(hp,getMaxHitPoints()));\r\n    }\r\n\r\n    /**\r\n     * Lets a hero pick up an equipable item of the ground and equip it in one of its anchor points.\r\n     *\r\n     * @param item\r\n     *        the item that will be picked up.\r\n     * @param anchortype\r\n     *        the name of the anchor where the item has to be equipped to.\r\n     *\r\n     * @effect The item gets picked up and equipped it in the anchorslot with the given type.\r\n     *         super.pickUp(item, anchortype)\r\n     *\r\n     * @throws ItemAlreadyobtainedException\r\n     *         The item already has a holder which means it can't be picked up.\r\n     *         |item.getHolder == null\r\n     * @throws IllegalArgumentException\r\n     *         The item is not effective\r\n     *         |item == null\r\n     * @throws AnchorslotOquipiedException\r\n     *         The creature is already holding an item in the anchor with the given anchortype\r\n     *         |anchor.getItem() != null\r\n     * @throws CarryLimitReachedException\r\n     *         The given item is can't be picked up because the creature cannot carry it anymore\r\n     *         because the maximum carry capacity has been reached. In case the user wants to pick up a backpack,\r\n     *         the contents of this backpack are also considered for the calculation of the weight of the item.\r\n     *         If the user tries to pick up more than 2 armors this error is also thrown.\r\n     *         |item.getTotalWeight > getCapacity || (item instanceof Armor && this.getNbOfArmors = 2)\r\n     * @throws BeltAnchorException\r\n     *         The user wants to equip an item that isn't a purse to the belt anchorslot of the hero.\r\n     *         |anchortype.getName() == \"Riem\" && item not instanceof Purse\r\n     */\r\n    @Override @Raw\r\n    public void pickUp(Equipable item, AnchorType anchortype) throws ItemAlreadyobtainedException,IllegalArgumentException,\r\n            AnchorslotOquipiedException, CarryLimitReachedException, BeltAnchorException{\r\n        if(!canPickUpArmor() && item instanceof Armor)\r\n            throw new CarryLimitReachedException(item);\r\n        super.pickUp(item, anchortype);\r\n    }\r\n\r\n    /**\r\n     * Stores an item, equipped in an anchorslot, away in a specified backpack.\r\n     *\r\n     * @param item\r\n     *        The item to be stored away.\r\n     * @param backpack\r\n     *        The backpack to store the item away in.\r\n     *\r\n     * @effect The specified item is added to the contents of the specified backpack\r\n     *         |backpack.addEquipable(item);\r\n     * @effect The anchoritem of the anchor that the item was previously being stored in, is set to null\r\n     *         |itemanchor.setItem(null);\r\n     *\r\n     * @throws IllegalArgumentException\r\n     *         The backpack is not effective or the specified backpack is not a backpack of this hero\r\n     *         |(backpack.getHolder() != this || backpack == null)\r\n     * @throws IllegalArgumentException\r\n     *         The item is not effective or the specified item is not a item of this hero\r\n     *         |(item.getHolder() != this || item == null)\r\n     * @throws IllegalArgumentException\r\n     *         The backpack or the item is currently not being stored in an anchor, meaning that they are being stored in a backpack.\r\n     *         Because backpacks in backpacks may not contain items and items already in a backpack cannot be stored away, an exception\r\n     *         is thrown.\r\n     */\r\n    @Raw\r\n    public void store(Equipable item, Backpack backpack) throws IllegalArgumentException{\r\n\r\n        if(backpack.getHolder() != this || backpack == null)\r\n            throw new IllegalArgumentException();\r\n\r\n        if(item.getHolder() != this || item == null)\r\n            throw new IllegalArgumentException();\r\n\r\n        Anchor backpackanchor = null;\r\n        Anchor itemanchor = null;\r\n        //als rugzak niet in een anchor, throw error\r\n        for(int i= 0; i < getAnchors().size(); i++){\r\n            if(getAnchorItemAt(i) == backpack){\r\n                backpackanchor = getAnchorAt(i);\r\n            }\r\n            else if(getAnchorItemAt(i) == item)\r\n                itemanchor = getAnchorAt(i);\r\n        }\r\n        if(backpackanchor == null || itemanchor == null){\r\n            throw new IllegalArgumentException();\r\n        }\r\n\r\n        try {\r\n            backpack.addEquipable(item);\r\n        } catch (BackPackNotEmptyException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (CarryLimitReachedException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (OtherPlayersItemException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (ItemAlreadyobtainedException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n        itemanchor.setItem(null);\r\n    }\r\n\r\n    /**\r\n     * Picks an item of the ground and immediately stores it away in a specified backpack.\r\n     *\r\n     * @param item\r\n     *        the item to be picked up.\r\n     * @param backpack\r\n     *        the backpack to store the item away in.\r\n     * @effect The item in the left or right hand that isn't the specified backpack is saved and temporarily set to null, the\r\n     *         specified item gets picked up.\r\n     *         |Equipable currholding = getAnchorItemAt(i);\r\n     *         |getAnchorAt(i).setItem(null);\r\n     *         |pickUp(item, getAnchorAt(i).getAnchorType());\r\n     * @effect The newly picked up item gets stored away in the specified backpack. Finally, the saved item is equiped again in the original anchorslot.\r\n     *         |store(item,backpack)\r\n     *\r\n     * @throws IllegalArgumentException\r\n     *         the item or the backpack is not effective\r\n     *         |(item == null || backpack == null)\r\n     * @throws ItemAlreadyobtainedException\r\n     *         This hero already has this item\r\n     *         |item.getholder == this\r\n     * @throws OtherPlayersItemException\r\n     *        the backpack or the item belongs the another player.\r\n     *        |backpack.getHolder() != this || item.getHolder() != null\r\n     * @throws CarryLimitReachedException\r\n     *         The item cannot be picked up because the specified backpack doesn't have enough capacity left\r\n     *         |backpack.getCapacity() < backpack.getTotalWeight() + item.getWeight()\r\n     * @throws IllegalArgumentException\r\n     *         The item we want to pick up is a backpack which isn't empty.\r\n     *         |((Backpack) item).getTotalWeight() != item.getWeight()\r\n     * @throws IllegalArgumentException\r\n     *         The specified backpack is already being stored within another backpack.\r\n     *         |backpack.getParentbackpack() != null\r\n     */\r\n    @Raw\r\n    public void pickUpAndStore(Equipable item, Backpack backpack) throws OtherPlayersItemException, CarryLimitReachedException,\r\n            ItemAlreadyobtainedException, IllegalArgumentException{\r\n\r\n        //checkers invoeren i suppose om error te voorkomen in try catch blok\r\n        // is item of backapck niet al van iemand anders\r\n        if(item == null || backpack == null)\r\n            throw new IllegalArgumentException();\r\n        if(item.getHolder() == this)\r\n            throw new ItemAlreadyobtainedException();\r\n        if(backpack.getHolder() != this || item.getHolder() != null)\r\n            throw new OtherPlayersItemException();\r\n        if(backpack.getCapacity() < backpack.getTotalWeight() + item.getWeight())\r\n            throw new CarryLimitReachedException(item);\r\n        if(item instanceof Backpack)\r\n            if(((Backpack) item).getTotalWeight() != item.getWeight())\r\n                throw new IllegalArgumentException();\r\n        if(backpack.getParentbackpack() != null)\r\n            throw new IllegalArgumentException();\r\n\r\n        /**\r\n         * het item in onze hand dat niet de rugzak is wordt even op de grond gelegd om een item op te pakken.\r\n         */\r\n        int i = 0;\r\n        Equipable currholding = getAnchorItemAt(0);\r\n        if(currholding == backpack){\r\n            i++;\r\n            currholding = getAnchorItemAt(i);\r\n        }\r\n        getAnchorAt(i).setItem(null);\r\n\r\n        //We proberen het item op te pakken\r\n        try {\r\n            pickUp(item, getAnchorAt(i).getAnchorType());\r\n            store(item, backpack);\r\n        }  catch (AnchorslotOquipiedException e) {\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            //Het wapen wordt weer vastgenomen\r\n            getAnchorAt(i).setItem(currholding);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes an item out of the backpack that the item is stored in and moves it to the specified Anchor if that anchor is empty.\r\n     *\r\n     * @param item\r\n     *        The item to be taken out of its backpack\r\n     * @param location\r\n     *        The anchorpoint of the hero to move the item to\r\n     *\r\n     * @effect The item is removed from the content of the backpack\r\n     *         |item.getParentbackpack().removeEquipable(item);\r\n     * @effet The item of the specified anchor is set to the given item\r\n     *        |anchor.setItem(item)\r\n     *\r\n     * @throws IllegalArgumentException\r\n     *         the given item is currently not being stored in a backpack.\r\n     *         |item.getParentbackpack() = null\r\n     * @throws OtherPlayersItemException\r\n     *         the item is being stored in a backpack that isn't a backpack of this hero\r\n     *         |item.getParent.getHolder() != this\r\n     * @throws BeltAnchorException\r\n     *         The user wants to equip an item that isn't a purse to the belt anchorslot of the hero.\r\n     *         |anchortype.getName() == \"Riem\" && item not instanceof Purse\r\n     * @throws AnchorslotOquipiedException\r\n     *         The anchor location does not exist or already has an item equiped in this slot\r\n     *         |anchor.getItem() != null || getAnchors.contains(anchortype) == false\r\n     */\r\n    @Raw\r\n    public void Equip(Equipable item, AnchorType location) throws IllegalArgumentException, OtherPlayersItemException, AnchorslotOquipiedException, BeltAnchorException{\r\n\r\n        Backpack parent = item.getParentbackpack();\r\n        if(parent == null)\r\n            throw new IllegalArgumentException();\r\n        if(parent.getHolder() != this)\r\n            throw new OtherPlayersItemException();\r\n        if (location.getName() == \"Riem\" && !(item instanceof Purse))\r\n            throw new BeltAnchorException();\r\n\r\n        Anchor anchor = null;\r\n\r\n        for (int i = 0; i < getAnchors().size(); i++) {\r\n            Anchor curranchor = getAnchorAt(i);\r\n            if (curranchor.getAnchorType() == location) {\r\n                if(curranchor.getItem() == null){\r\n                    anchor = curranchor;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if(anchor == null)\r\n            throw new AnchorslotOquipiedException();\r\n\r\n        parent.removeEquipable(item);\r\n        anchor.setItem(item);\r\n    }\r\n\r\n    /**\r\n     * Moves an item from the first specified anchor to the second anchor if the second Anchor is empty.\r\n     *\r\n     * @param start\r\n     *        the anchor to move the item from\r\n     * @param end\r\n     *        the anchor to move the item to\r\n     *\r\n     * @effect the item in the start anchor is set to null\r\n     *         |start.setItem(null)\r\n     * @effect the item in the end anchor is set to the item in the start anchor\r\n     *         |end.setItem(start.getItem())\r\n     *\r\n     * @throws AnchorslotOquipiedException\r\n     *         The endAnchor already has an item equiped to it\r\n     *         |end.getItem() != null\r\n     * @throws BeltAnchorException\r\n     *         The user wants to equip an item that isn't a purse to the belt anchorslot of the creature.\r\n     *         |anchortype.getName() == \"Riem\" && item not instanceof Purse\r\n     */\r\n    public void moveAnchorItemtoAnchor(AnchorType start, AnchorType end) throws AnchorslotOquipiedException, BeltAnchorException{\r\n\r\n        Anchor startanchor = null;\r\n        Anchor endanchor = null;\r\n\r\n        for (int i = 0; i < getAnchors().size(); i++) {\r\n            Anchor curranchor = getAnchorAt(i);\r\n            if (curranchor.getAnchorType() == start)\r\n                startanchor = curranchor;\r\n            if(curranchor.getAnchorType() == end)\r\n                endanchor = curranchor;\r\n        }\r\n        if(startanchor != endanchor){\r\n            Equipable startitem = startanchor.getItem();\r\n            if(endanchor.getItem() != null)\r\n                throw new AnchorslotOquipiedException();\r\n            if (end.getName() == \"Riem\" && !(startitem instanceof Purse))\r\n                throw new BeltAnchorException();\r\n\r\n            startanchor.setItem(null);\r\n            endanchor.setItem(startitem);\r\n             }\r\n    }\r\n\r\n    private int getNbOfArmors(){\r\n       int total = 0;\r\n        for (int i = 0; i < getAnchors().size(); i++){\r\n            Equipable currItem = getAnchorItemAt(i);\r\n            if(currItem instanceof Armor)\r\n                total++;\r\n            else if (currItem instanceof Backpack) {\r\n                total= total +((Backpack) currItem).getNbOfArmors();\r\n            }\r\n        }\r\n        return total;\r\n    }\r\n\r\n    private boolean canPickUpArmor(){\r\n        return (getNbOfArmors() < 2);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Swaps the postion of the two armors that a hero is currently carrying with him\r\n     */\r\n    public void swapArmors(Armor armor) throws CantFindArmortoSwapException, CarryLimitReachedException, OtherPlayersItemException {\r\n        if(getNbOfArmors() != 2)\r\n            throw new CantFindArmortoSwapException();\r\n        Equipable bodyitem = getAnchorItemAt(3);\r\n        if(!(bodyitem instanceof Armor))\r\n            throw new CantFindArmortoSwapException();\r\n\r\n\r\n        Backpack parent = armor.getParentbackpack();\r\n        if(parent != null){ //armor zit in een rugzak\r\n            int weight = parent.getTotalWeight() - armor.getWeight() + bodyitem.getWeight();\r\n            if(weight > parent.getCapacity())\r\n                throw new CarryLimitReachedException(bodyitem);\r\n\r\n            drop(armor);\r\n            store(bodyitem,parent);\r\n\r\n            try {\r\n                pickUp(bodyitem,AnchorType.LICHAAM);\r\n            } catch (ItemAlreadyobtainedException e) {\r\n                throw new RuntimeException(e);\r\n            } catch (AnchorslotOquipiedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n        //armor zit in een Anchor\r\n\r\n        Anchor curranchor = null;\r\n        for (int i = 0; i < getAnchors().size(); i++) {\r\n            curranchor = getAnchorAt(i);\r\n            if(curranchor.getItem() == armor)\r\n                break;\r\n        }\r\n        drop(bodyitem);\r\n        try {\r\n            moveAnchorItemtoAnchor(curranchor.getAnchorType(), AnchorType.LICHAAM);\r\n        } catch (AnchorslotOquipiedException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n        try {\r\n            pickUp(bodyitem,curranchor.getAnchorType());\r\n        } catch (ItemAlreadyobtainedException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (AnchorslotOquipiedException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n    /**\r\n     * Gives the closest positive prime number to a number that isn't bigger than a given maximum.\r\n     * @param number\r\n     *        The number that you want the closest prime of.\r\n     * @param max\r\n     *        The maximum, the returned prime number can't be bigger than this value.\r\n     * @return The closest prime number.\r\n     * @pre    The given maximum must be 2 or higher, otherwise there will be no prime number.\r\n     */\r\n    @Model\r\n    private static int findClosestPrime(int number, int max) {\r\n        if (isPrime(number)) {\r\n            return number;  // If the number itself is prime, return it\r\n        }\r\n        int smaller = number - 1;\r\n        int larger = number + 1;\r\n        while (true) {\r\n            if (isPrime(smaller)) {\r\n                return smaller;\r\n            }\r\n            if (isPrime(larger)) {\r\n                return larger;\r\n            }\r\n            if(smaller > 0){\r\n                smaller--;}\r\n            if(larger < max){\r\n                larger++;}\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function to determine if a number is prime.\r\n     * @param number\r\n     *        the number\r\n     * @return True if it is prime and false if it is not. Prime means that it is only divisible by 1 and itself.\r\n     *         |if (number <= 1)\r\n     *         |        return false\r\n     *         |\r\n     *         |for (int i = 2; i <= Math.sqrt(number); i++)\r\n     *         |        if (number % i == 0)\r\n     *         |                return false\r\n     */\r\n    @Model\r\n    private static boolean isPrime(int number) {\r\n        if (number <= 1) {\r\n            return false;\r\n        }\r\n        for (int i = 2; i <= Math.sqrt(number); i++) {\r\n            if (number % i == 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/RPG/Hero.java b/src/RPG/Hero.java
--- a/src/RPG/Hero.java	(revision 7615e532895fb21acdbee5946f0f63706cfcf319)
+++ b/src/RPG/Hero.java	(date 1683652322690)
@@ -14,7 +14,9 @@
  *
  *
  * @invar a hero may only carry up to 2 armors at a time.
- *       |canCarryArmor
+ *       |canCarryArmor()
+ * @invar the 'belt' AnchorSlot may only contain equipables of the 'purse' type.
+ *      |hier nog shit schrijven
  */
 public class Hero extends Creature{
 
@@ -559,6 +561,10 @@
              }
     }
 
+    /**
+     * Returns the total number of armors that a hero is currently carrying in his anchors and backpacks.
+     */
+    @Model
     private int getNbOfArmors(){
        int total = 0;
         for (int i = 0; i < getAnchors().size(); i++){
@@ -572,14 +578,18 @@
         return total;
     }
 
-    private boolean canPickUpArmor(){
+    /**
+     * @return True if the total number of armors that this hero is currently carrying is smaller than 2. False otherwise.
+     */
+    @Raw
+    public boolean canPickUpArmor(){
         return (getNbOfArmors() < 2);
     }
 
 
 
     /**
-     * Swaps the postion of the two armors that a hero is currently carrying with him
+     * Swaps the postion of the two armors that a hero is currently carrying with him. Deze shit fiksen zodat pickup en drop in 1 stap worden afgehandelt. FUN!
      */
     public void swapArmors(Armor armor) throws CantFindArmortoSwapException, CarryLimitReachedException, OtherPlayersItemException {
         if(getNbOfArmors() != 2)
@@ -588,45 +598,61 @@
         if(!(bodyitem instanceof Armor))
             throw new CantFindArmortoSwapException();
 
-
         Backpack parent = armor.getParentbackpack();
-        if(parent != null){ //armor zit in een rugzak
-            int weight = parent.getTotalWeight() - armor.getWeight() + bodyitem.getWeight();
-            if(weight > parent.getCapacity())
-                throw new CarryLimitReachedException(bodyitem);
+        if(armor.getHolder() == this) {
+            if (parent != null) { //armor zit in een rugzak
+                int weight = parent.getTotalWeight() - armor.getWeight() + bodyitem.getWeight();
+                if (weight > parent.getCapacity())
+                    throw new CarryLimitReachedException(bodyitem);
 
-            drop(armor);
-            store(bodyitem,parent);
+                parent.removeEquipable(armor);
+                store(bodyitem, parent);
 
-            try {
-                pickUp(bodyitem,AnchorType.LICHAAM);
-            } catch (ItemAlreadyobtainedException e) {
-                throw new RuntimeException(e);
-            } catch (AnchorslotOquipiedException e) {
-                throw new RuntimeException(e);
-            }
-        }
-        //armor zit in een Anchor
-
-        Anchor curranchor = null;
-        for (int i = 0; i < getAnchors().size(); i++) {
-            curranchor = getAnchorAt(i);
-            if(curranchor.getItem() == armor)
-                break;
-        }
-        drop(bodyitem);
-        try {
-            moveAnchorItemtoAnchor(curranchor.getAnchorType(), AnchorType.LICHAAM);
-        } catch (AnchorslotOquipiedException e) {
-            throw new RuntimeException(e);
-        }
-        try {
-            pickUp(bodyitem,curranchor.getAnchorType());
-        } catch (ItemAlreadyobtainedException e) {
-            throw new RuntimeException(e);
-        } catch (AnchorslotOquipiedException e) {
-            throw new RuntimeException(e);
-        }
+                try {
+                    pickUp(armor, AnchorType.LICHAAM);
+                } catch (ItemAlreadyobtainedException e) {
+                    throw new RuntimeException(e);
+                } catch (AnchorslotOquipiedException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+            //armor zit in een Anchor
+            else {
+                Anchor curranchor = null;
+                for (int i = 0; i < getAnchors().size(); i++) {
+                    curranchor = getAnchorAt(i);
+                    if (curranchor.getItem() == armor)
+                        break;
+                }
+                drop(bodyitem);
+                try {
+                    moveAnchorItemtoAnchor(curranchor.getAnchorType(), AnchorType.LICHAAM);
+                } catch (AnchorslotOquipiedException e) {
+                    throw new RuntimeException(e);
+                }
+                try {
+                    pickUp(bodyitem, curranchor.getAnchorType());
+                } catch (ItemAlreadyobtainedException e) {
+                    throw new RuntimeException(e);
+                } catch (AnchorslotOquipiedException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+        } else if (armor.getHolder() == null) {
+            if(getCapacity() - bodyitem.getWeight() + armor.getWeight() > getMaxCapacity())
+                throw new CarryLimitReachedException(armor);
+            drop(bodyitem);
+            try {
+                pickUp(armor, AnchorType.LICHAAM);
+            } catch (ItemAlreadyobtainedException e) {
+                throw new RuntimeException(e);
+            } catch (AnchorslotOquipiedException e) {
+                throw new RuntimeException(e);
+            }
+
+
+        } else
+            throw new IllegalArgumentException();
     }
     /**
      * Gives the closest positive prime number to a number that isn't bigger than a given maximum.
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"69444ef7-e217-4129-a0a3-0f7997122e5f\" name=\"Changes\" comment=\"healen\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/RPG/Backpack.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/RPG/Backpack.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/RPG/Creature.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/RPG/Creature.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/RPG/Hero.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/RPG/Hero.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/RPG/Weapon.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/RPG/Weapon.java\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Enum\" />\r\n        <option value=\"Enum\" />\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"2OxCm5qWox6dHBXc5DGPKeGW1AR\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/Users/bramo/OneDrive/Documenten/Unief jaar 2/semester 2/OGP/ExamenProjectBramWout&quot;,\r\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;project.structure.last.edited&quot;: &quot;Libraries&quot;,\r\n    &quot;project.structure.proportion&quot;: &quot;0.0&quot;,\r\n    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.editor&quot;,\r\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"Main\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"RPG.Main\" />\r\n      <module name=\"ExamenProjectBramWout\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"RPG.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Application.Main\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"69444ef7-e217-4129-a0a3-0f7997122e5f\" name=\"Changes\" comment=\"\" />\r\n      <created>1682493008413</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1682493008413</updated>\r\n      <workItem from=\"1682493009655\" duration=\"2000\" />\r\n      <workItem from=\"1682495227075\" duration=\"20387000\" />\r\n      <workItem from=\"1682686382687\" duration=\"7218000\" />\r\n      <workItem from=\"1682783690778\" duration=\"6520000\" />\r\n      <workItem from=\"1682862326382\" duration=\"17601000\" />\r\n      <workItem from=\"1682955414409\" duration=\"13205000\" />\r\n      <workItem from=\"1682981522832\" duration=\"165000\" />\r\n      <workItem from=\"1683019024939\" duration=\"4623000\" />\r\n      <workItem from=\"1683213889039\" duration=\"3524000\" />\r\n      <workItem from=\"1683380268212\" duration=\"10148000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"al de basis setters, getters en checkers gemaakt, bezig met constructor\">\r\n      <created>1682503734612</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682503734612</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"al de basis setters, getters en checkers gemaakt, bezig met constructor\">\r\n      <created>1682503750873</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682503750873</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"anchors en anchortypes toegevoegd\">\r\n      <created>1682515185209</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682515185209</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"anchors en anchortypes toegevoegd\">\r\n      <created>1682515250708</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682515250708</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"constructor afgewerkt\">\r\n      <created>1682516931020</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682516931020</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"constructor afgewerkt\">\r\n      <created>1682517123747</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682517123747</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"constructor afgewerkt\">\r\n      <created>1682530570486</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682530570486</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\"setname override klaar\">\r\n      <created>1682602946401</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682602946401</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00009\" summary=\"begonnen met monster\">\r\n      <created>1682604429034</created>\r\n      <option name=\"number\" value=\"00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682604429034</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00010\" summary=\"Armor protection gemplementeerd met tijdsafhankelijke slijtage.\">\r\n      <created>1682775466943</created>\r\n      <option name=\"number\" value=\"00010\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682775466943</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00011\" summary=\"Begonnen aan value\">\r\n      <created>1682778794557</created>\r\n      <option name=\"number\" value=\"00011\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682778794557</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00012\" summary=\"Value voor wapens gemplementeerd\">\r\n      <created>1682779894729</created>\r\n      <option name=\"number\" value=\"00012\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682779894729</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00013\" summary=\"Value volledig gemplementeerd\">\r\n      <created>1682794403377</created>\r\n      <option name=\"number\" value=\"00013\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682794403377</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00014\" summary=\"Capacity en Contents van backpack volledig gemplementeerd\">\r\n      <created>1682882414293</created>\r\n      <option name=\"number\" value=\"00014\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682882414293</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00015\" summary=\"Het oppakken van een item dat op de grond ligt en het wegsteken ervan in een rugzak gemplementeerd\">\r\n      <created>1682980932657</created>\r\n      <option name=\"number\" value=\"00015\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682980932657</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00016\" summary=\"Kleine bug voor monsters gefikst\">\r\n      <created>1682981682620</created>\r\n      <option name=\"number\" value=\"00016\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00016\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682981682620</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00017\" summary=\"healen\">\r\n      <created>1683468043509</created>\r\n      <option name=\"number\" value=\"00017\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00017\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1683468043509</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00018\" summary=\"healen\">\r\n      <created>1683468193887</created>\r\n      <option name=\"number\" value=\"00018\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00018\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1683468193887</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"19\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"al de basis setters, getters en checkers gemaakt, bezig met constructor\" />\r\n    <MESSAGE value=\"anchors en anchortypes toegevoegd\" />\r\n    <MESSAGE value=\"constructor afgewerkt\" />\r\n    <MESSAGE value=\"Identificatie van Items gemplementeerd\" />\r\n    <MESSAGE value=\"Gewicht van Equipables en damage van wapens gemplementeerd\" />\r\n    <MESSAGE value=\"Armor protection gemplementeerd met tijdsafhankelijke slijtage.\" />\r\n    <MESSAGE value=\"Begonnen aan value\" />\r\n    <MESSAGE value=\"Value voor wapens gemplementeerd\" />\r\n    <MESSAGE value=\"Value volledig gemplementeerd\" />\r\n    <MESSAGE value=\"Capacity en Contents van backpack volledig gemplementeerd\" />\r\n    <MESSAGE value=\"Het oppakken van een item dat op de grond ligt en het wegsteken ervan in een rugzak gemplementeerd\" />\r\n    <MESSAGE value=\"Kleine bug voor monsters gefikst\" />\r\n    <MESSAGE value=\"healen\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"healen\" />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <breakpoint enabled=\"true\" type=\"java-exception\">\r\n          <properties class=\"java.lang.NullPointerException\" package=\"java.lang\" />\r\n          <option name=\"timeStamp\" value=\"2\" />\r\n        </breakpoint>\r\n        <breakpoint enabled=\"true\" type=\"java-exception\">\r\n          <properties class=\"java.lang.RuntimeException\" package=\"java.lang\" />\r\n          <option name=\"timeStamp\" value=\"19\" />\r\n        </breakpoint>\r\n        <line-breakpoint enabled=\"true\" type=\"java-line\">\r\n          <url>file://$PROJECT_DIR$/src/RPG/Main.java</url>\r\n          <line>106</line>\r\n          <option name=\"timeStamp\" value=\"23\" />\r\n        </line-breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n  <component name=\"XSLT-Support.FileAssociations.UIState\">\r\n    <expand />\r\n    <select />\r\n  </component>\r\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\r\n    <SUITE FILE_PATH=\"coverage/ExamenProjectBramWout$Main.ic\" NAME=\"Main Coverage Results\" MODIFIED=\"1682784192722\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"idea\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\">\r\n      <FILTER>RPG.*</FILTER>\r\n    </SUITE>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 7615e532895fb21acdbee5946f0f63706cfcf319)
+++ b/.idea/workspace.xml	(date 1683546823071)
@@ -5,10 +5,17 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="69444ef7-e217-4129-a0a3-0f7997122e5f" name="Changes" comment="healen">
+    <list default="true" id="69444ef7-e217-4129-a0a3-0f7997122e5f" name="Changes" comment="Extra functionaliteiten in verband met laten vallen en oppakken van Items gemplementeerd. Biderectionele relatie tussen equipables en backpacks opgestelt.">
+      <change afterPath="$PROJECT_DIR$/src/RPG/CantFindArmortoSwapException.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/RPG/Purse.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/RPG/Armor.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/RPG/Armor.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/RPG/ArmorType.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/RPG/ArmorType.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/RPG/Backpack.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/RPG/Backpack.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/RPG/BeltAnchorException.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/RPG/BeltAnchorException.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/RPG/Creature.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/RPG/Creature.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/RPG/Hero.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/RPG/Hero.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/RPG/Monster.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/RPG/Monster.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/RPG/Weapon.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/RPG/Weapon.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
@@ -91,7 +98,7 @@
       <workItem from="1682981522832" duration="165000" />
       <workItem from="1683019024939" duration="4623000" />
       <workItem from="1683213889039" duration="3524000" />
-      <workItem from="1683380268212" duration="10148000" />
+      <workItem from="1683380268212" duration="27418000" />
     </task>
     <task id="LOCAL-00001" summary="al de basis setters, getters en checkers gemaakt, bezig met constructor">
       <created>1682503734612</created>
@@ -220,6 +227,14 @@
       <updated>1683468193887</updated>
     </task>
     <option name="localTasksCounter" value="19" />
+    <task id="LOCAL-00017" summary="Extra functionaliteiten in verband met laten vallen en oppakken van Items gemplementeerd. Biderectionele relatie tussen equipables en backpacks opgestelt.">
+      <created>1683391073171</created>
+      <option name="number" value="00017" />
+      <option name="presentableId" value="LOCAL-00017" />
+      <option name="project" value="LOCAL" />
+      <updated>1683391073171</updated>
+    </task>
+    <option name="localTasksCounter" value="18" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -249,6 +264,8 @@
     <MESSAGE value="Capacity en Contents van backpack volledig gemplementeerd" />
     <MESSAGE value="Het oppakken van een item dat op de grond ligt en het wegsteken ervan in een rugzak gemplementeerd" />
     <MESSAGE value="Kleine bug voor monsters gefikst" />
+    <MESSAGE value="Extra functionaliteiten in verband met laten vallen en oppakken van Items gemplementeerd. Biderectionele relatie tussen equipables en backpacks opgestelt." />
+    <option name="LAST_COMMIT_MESSAGE" value="Extra functionaliteiten in verband met laten vallen en oppakken van Items gemplementeerd. Biderectionele relatie tussen equipables en backpacks opgestelt." />
     <MESSAGE value="healen" />
     <option name="LAST_COMMIT_MESSAGE" value="healen" />
   </component>
